
val x86_push_general_register : (int, int, int, int, int, int, int, int, int) -> int effect {eamem, escape, rreg, wmv, wreg}

function x86_push_general_register (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-PUSH-GENERAL-REGISTER" : string;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
    } else {
        let reg = loghead(3, opcode) : int;
        let sailval = rgfi_size(operand_size, reg_index(reg, rex_byte, 0), rex_byte, 0) : int;
        let badlength? = check_instruction_length(start_rip, temp_rip, 0) : option(int);
        if is_some(badlength?) then {
            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':INSTRUCTION-LENGTH', 'BADLENGTH?']"))
        } else {
            let (flg, x86) = wme_size(proc_mode, operand_size, new_rsp, 2, sailval, alignment_checking_enabled_p(0), 0, struct { mem_ptr? = false }) : (option(string), int);
            if is_some(flg) then {
                throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
            } else {
                let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
                let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
                0
            }
        }
    }
}

val x86_push_ev : (int, int, int, int, int, int, int, int, int) -> int effect {eamem, escape, rmem, rreg, wmv, wreg}

function x86_push_ev (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-PUSH-EV" : string;
    let r_m = modr_m_get_r_m(modr_m) : int;
    let mod_var = modr_m_get_mod(modr_m) : int;
    let reg = modr_m_get_reg(modr_m) : int;
    let p2 = prefixes_get_seg(prefixes) : int;
    let p4? = (103 == prefixes_get_adr(prefixes)) : bool;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
    } else {
        let seg_reg = select_segment_register(proc_mode, p2, p4?, mod_var, r_m, sib, 0) : int;
        let (flg0, e, increment_rip_by, e_addr, x86) = x86_operand_from_modr_m_and_sib_bytes(proc_mode, 0, operand_size, true, false, seg_reg, p4?, temp_rip, rex_byte, r_m, mod_var, sib, 0, 0) : (option(string), int, int, int, int);
        if is_some(flg0) then {
            throw(Emsg("Model state error: :X86-OPERAND-FROM-MODR/M-AND-SIB-BYTES"))
        } else {
            let (flg, temp_rip) = add_to_iptr(proc_mode, temp_rip, increment_rip_by, 0) : (option(string), int);
            if is_some(flg) then {
                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':INCREMENT-IP-ERROR', 'FLG']"))
            } else {
                let badlength? = check_instruction_length(start_rip, temp_rip, 0) : option(int);
                if is_some(badlength?) then {
                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':INSTRUCTION-LENGTH', 'BADLENGTH?']"))
                } else {
                    let (flg, x86) = wme_size(proc_mode, operand_size, new_rsp, 2, e, alignment_checking_enabled_p(0), 0, struct { mem_ptr? = false }) : (option(string), int);
                    if is_some(flg) then {
                        throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
                    } else {
                        let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
                        let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
                        0
                    }
                }
            }
        }
    }
}

val x86_push_i : (int, int, int, int, int, int, int, int, int) -> int effect {eamem, escape, rmem, rreg, wmv, wreg}

function x86_push_i (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-PUSH-I" : string;
    let byte_imm? = (opcode == 106) : bool;
    let imm_size = select_operand_size(proc_mode, byte_imm?, rex_byte, true, prefixes, false, false, false, 0) : int;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
    } else {
        let (flg0, imm, x86) = rime_size(proc_mode, imm_size, temp_rip, 1, ":X", false, 0, struct { mem_ptr? = false }) : (option(string), int, int);
        if is_some(flg0) then {
            throw(Emsg("Model state error: :IMM-RIME-SIZE-ERROR"))
        } else {
            let (flg, temp_rip) = add_to_iptr(proc_mode, temp_rip, imm_size, 0) : (option(string), int);
            if is_some(flg) then {
                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':TEMP-RIP-NOT-CANONICAL', 'TEMP-RIP']"))
            } else {
                let badlength? = check_instruction_length(start_rip, temp_rip, 0) : option(int);
                if is_some(badlength?) then {
                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':INSTRUCTION-LENGTH', 'BADLENGTH?']"))
                } else {
                    let (flg1, x86) = wme_size(proc_mode, operand_size, new_rsp, 2, loghead(ash(operand_size, 3), imm), alignment_checking_enabled_p(0), 0, struct { mem_ptr? = false }) : (option(string), int);
                    if is_some(flg1) then {
                        throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
                    } else {
                        let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
                        let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
                        0
                    }
                }
            }
        }
    }
}

val x86_push_segment_register : (int, int, int, int, int, int, int, int, int) -> int effect {eamem, escape, rreg, wmv, wreg}

function x86_push_segment_register (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-PUSH-SEGMENT-REGISTER" : string;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
    } else {
        let sailval = seg_visiblei((match opcode {
          14 => 1,
          22 => 2,
          30 => 3,
          6 => 0,
          160 => 4,
          _ => 5
        }) : int, 0) : int;
        let (flg, x86) = wme_size(proc_mode, if operand_size == 4 then 2 else {
            operand_size
        }, new_rsp, 2, sailval, alignment_checking_enabled_p(0), 0, struct { mem_ptr? = false }) : (option(string), int);
        if is_some(flg) then {
            throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
        } else {
            let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
            let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
            0
        }
    }
}

val x86_pop_general_register : (int, int, int, int, int, int, int, int, int) -> int effect {escape, rmem, rreg, wreg}

function x86_pop_general_register (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-POP-GENERAL-REGISTER" : string;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
    } else {
        let (flg0, sailval, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", alignment_checking_enabled_p(0), 0, struct { mem_ptr? = false }) : (option(string), int, int);
        if is_some(flg0) then {
            throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
        } else {
            let reg = binary_logand(opcode, 7) : int;
            let badlength? = check_instruction_length(start_rip, temp_rip, 0) : option(int);
            if is_some(badlength?) then {
                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':INSTRUCTION-LENGTH', 'BADLENGTH?']"))
            } else {
                let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
                let x86 = write_rgfi_size(operand_size, reg_index(reg, rex_byte, 0), sailval, rex_byte, 0) : int;
                let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
                0
            }
        }
    }
}

val x86_pop_ev : (int, int, int, int, int, int, int, int, int) -> int effect {eamem, escape, rmem, rreg, wmv, wreg}

function x86_pop_ev (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-POP-EV" : string;
    let r_m = modr_m_get_r_m(modr_m) : int;
    let mod_var = modr_m_get_mod(modr_m) : int;
    let reg = modr_m_get_reg(modr_m) : int;
    let p2 = prefixes_get_seg(prefixes) : int;
    let p4? = (103 == prefixes_get_adr(prefixes)) : bool;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
    } else {
        let check_alignment? = alignment_checking_enabled_p(0) : bool;
        let (flg0, sailval, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
        if is_some(flg0) then {
            throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
        } else {
            let (flg1, addr, increment_rip_by, x86) = (if mod_var == 3 then {
                (None() : option(string), 0 : int, 0 : int, 0 : int)
            } else {
                x86_effective_addr(proc_mode, p4?, temp_rip, rex_byte, r_m, mod_var, sib, 0, 0)
            }) : (option(string), int, int, int);
            if is_some(flg1) then {
                throw(Emsg("Model state error: :X86-EFFECTIVE-ADDR-ERROR"))
            } else {
                let seg_reg = select_segment_register(proc_mode, p2, p4?, mod_var, r_m, sib, 0) : int;
                let (flg, temp_rip) = add_to_iptr(proc_mode, temp_rip, increment_rip_by, 0) : (option(string), int);
                if is_some(flg) then {
                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':INCREMENT-IP-ERROR', 'FLG']"))
                } else {
                    let badlength? = check_instruction_length(start_rip, temp_rip, 0) : option(int);
                    if is_some(badlength?) then {
                        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':GP', '0', ':INSTRUCTION-LENGTH', 'BADLENGTH?']"))
                    } else {
                        let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
                        let (flg3, x86) = x86_operand_to_reg_mem(proc_mode, operand_size, check_alignment?, false, sailval, seg_reg, addr, rex_byte, r_m, mod_var, 0) : (option(string), int);
                        if is_some(flg3) then {
                            throw(Emsg("Model state error: :X86-OPERAND-TO-REG/MEM"))
                        } else {
                            let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
                            0
                        }
                    }
                }
            }
        }
    }
}

val x86_pushf : (int, int, int, int, int, int, int, int, int) -> int effect {eamem, escape, rreg, wmv, wreg}

function x86_pushf (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-PUSHF" : string;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
    } else {
        let eflags = r_rflags(0) : int;
        let eflags = (match operand_size {
          2 => binary_logand(65535, eflags),
          _ => binary_logand(3997695, eflags)
        }) : int : int;
        let (flg, x86) = wme_size(proc_mode, operand_size, new_rsp, 2, eflags, alignment_checking_enabled_p(0), 0, struct { mem_ptr? = false }) : (option(string), int);
        if is_some(flg) then {
            throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
        } else {
            let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
            let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
            0
        }
    }
}

val x86_popf : (int, int, int, int, int, int, int, int, int) -> int effect {escape, rmem, rreg, wreg}

function x86_popf (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-POPF" : string;
    let operand_size = select_operand_size(proc_mode, false, rex_byte, false, prefixes, true, true, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let (flg, new_rsp) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
    } else {
        let (flg0, sailval, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", alignment_checking_enabled_p(0), 0, struct { mem_ptr? = false }) : (option(string), int, int);
        if is_some(flg0) then {
            throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
        } else {
            let sailval = binary_logior(2, binary_logand(4161495, sailval)) : int;
            let x86 = write_sptr(proc_mode, new_rsp, 0) : int;
            let x86 = (match operand_size {
              2 => write_rflags(sailval, 0),
              _ => let rf = (let rflags_var = r_rflags(0) : int in rflagsbits_get_rf(rflags_var)) : int in
                let vm = (let rflags_var = r_rflags(0) : int in rflagsbits_get_vm(rflags_var)) : int in
                  let x86 = write_rflags(sailval, 0) : int in
                    let x86 = (let rflags_var = r_rflags(0) : int in
                      let new_rflags = set_rflagsbits_get_rf(rf, rflags_var) : int in write_rflags(new_rflags, 0)) : int in
                      let x86 = (let rflags_var = r_rflags(0) : int in
                        let new_rflags = set_rflagsbits_get_vm(vm, rflags_var) : int in write_rflags(new_rflags, 0)) : int in
                        let x86 = (let rflags_var = r_rflags(0) : int in
                          let new_rflags = set_rflagsbits_get_vip(0, rflags_var) : int in write_rflags(new_rflags, 0)) : int in
                          let x86 = (let rflags_var = r_rflags(0) : int in
                            let new_rflags = set_rflagsbits_get_vif(0, rflags_var) : int in write_rflags(new_rflags, 0)) : int in
                            0
            }) : int : int;
            let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
            0
        }
    }
}

val x86_pusha : (int, int, int, int, int, int, int, int, int) -> int effect {eamem, escape, rreg, wmv, wreg}

function x86_pusha (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-PUSHA" : string;
    let operand_size = select_operand_size(proc_mode, false, 0, false, prefixes, false, false, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let eax_ax = rgfi_size(operand_size, 0, 0, 0) : int;
    let ecx_cx = rgfi_size(operand_size, 1, 0, 0) : int;
    let edx_dx = rgfi_size(operand_size, 2, 0, 0) : int;
    let ebx_bx = rgfi_size(operand_size, 3, 0, 0) : int;
    let esp_sp = rgfi_size(operand_size, 4, 0, 0) : int;
    let ebp_bp = rgfi_size(operand_size, 5, 0, 0) : int;
    let esi_si = rgfi_size(operand_size, 6, 0, 0) : int;
    let edi_di = rgfi_size(operand_size, 7, 0, 0) : int;
    let check_alignment? = alignment_checking_enabled_p(0) : bool;
    let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
    if is_some(flg) then {
        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
    } else {
        let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, eax_ax, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
        if is_some(flg) then {
            throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
        } else {
            let check_alignment? = false : bool;
            let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
            if is_some(flg) then {
                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
            } else {
                let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, ecx_cx, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
                if is_some(flg) then {
                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                } else {
                    let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
                    if is_some(flg) then {
                        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                    } else {
                        let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, edx_dx, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
                        if is_some(flg) then {
                            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                        } else {
                            let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
                            if is_some(flg) then {
                                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                            } else {
                                let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, ebx_bx, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
                                if is_some(flg) then {
                                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                } else {
                                    let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
                                    if is_some(flg) then {
                                        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                    } else {
                                        let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, esp_sp, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
                                        if is_some(flg) then {
                                            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                        } else {
                                            let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
                                            if is_some(flg) then {
                                                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                            } else {
                                                let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, ebp_bp, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
                                                if is_some(flg) then {
                                                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                                } else {
                                                    let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
                                                    if is_some(flg) then {
                                                        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                                    } else {
                                                        let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, esi_si, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
                                                        if is_some(flg) then {
                                                            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                                        } else {
                                                            let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, negate(operand_size), 0) : (option(string), int);
                                                            if is_some(flg) then {
                                                                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                                            } else {
                                                                let (flg, x86) = wme_size(proc_mode, operand_size, rsp_var, 2, edi_di, check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int);
                                                                if is_some(flg) then {
                                                                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':PUSH', 'FLG']"))
                                                                } else {
                                                                    let x86 = write_sptr(proc_mode, rsp_var, 0) : int;
                                                                    let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
                                                                    0
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

val x86_popa : (int, int, int, int, int, int, int, int, int) -> int effect {escape, rmem, rreg, wreg}

function x86_popa (proc_mode, start_rip, temp_rip, prefixes, rex_byte, opcode, modr_m, sib, x86) = {
    let ctx = "X86-POPA" : string;
    let operand_size = select_operand_size(proc_mode, false, 0, false, prefixes, false, false, false, 0) : int;
    let rsp_var = read_sptr(proc_mode, 0) : int;
    let check_alignment? = alignment_checking_enabled_p(0) : bool;
    let (flg, edi_di, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
    if is_some(flg) then {
        throw(Emsg("This error is generated by the translator and represents a more detailed error that occurred in `push-and-pop.lisp`"))
    } else {
        let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
        if is_some(flg) then {
            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
        } else {
            let check_alignment? = false : bool;
            let (flg, esi_si, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
            if is_some(flg) then {
                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
            } else {
                let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
                if is_some(flg) then {
                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                } else {
                    let (flg, ebp_bp, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
                    if is_some(flg) then {
                        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                    } else {
                        let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
                        if is_some(flg) then {
                            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                        } else {
                            let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
                            if is_some(flg) then {
                                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                            } else {
                                let (flg, ebx_bx, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
                                if is_some(flg) then {
                                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                } else {
                                    let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
                                    if is_some(flg) then {
                                        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                    } else {
                                        let (flg, edx_dx, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
                                        if is_some(flg) then {
                                            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                        } else {
                                            let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
                                            if is_some(flg) then {
                                                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                            } else {
                                                let (flg, ecx_cx, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
                                                if is_some(flg) then {
                                                    throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                                } else {
                                                    let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
                                                    if is_some(flg) then {
                                                        throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                                    } else {
                                                        let (flg, eax_ax, x86) = rme_size(proc_mode, operand_size, rsp_var, 2, ":R", check_alignment?, 0, struct { mem_ptr? = false }) : (option(string), int, int);
                                                        if is_some(flg) then {
                                                            throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                                        } else {
                                                            let (flg, rsp_var) = add_to_sptr(proc_mode, rsp_var, operand_size, 0) : (option(string), int);
                                                            if is_some(flg) then {
                                                                throw(Emsg("A fault occurred.  Original ACL2 AST:\n['!!FAULT-FRESH', ':SS', '0', ':POP', 'FLG']"))
                                                            } else {
                                                                let x86 = write_rgfi_size(operand_size, 7, edi_di, 0, 0) : int;
                                                                let x86 = write_rgfi_size(operand_size, 6, esi_si, 0, 0) : int;
                                                                let x86 = write_rgfi_size(operand_size, 5, ebp_bp, 0, 0) : int;
                                                                let x86 = write_rgfi_size(operand_size, 3, ebx_bx, 0, 0) : int;
                                                                let x86 = write_rgfi_size(operand_size, 2, edx_dx, 0, 0) : int;
                                                                let x86 = write_rgfi_size(operand_size, 1, ecx_cx, 0, 0) : int;
                                                                let x86 = write_rgfi_size(operand_size, 0, eax_ax, 0, 0) : int;
                                                                let x86 = write_sptr(proc_mode, rsp_var, 0) : int;
                                                                let x86 = write_iptr(proc_mode, temp_rip, 0) : int;
                                                                0
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
