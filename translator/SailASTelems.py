from lex_parse import NewLine, ACL2Comment
from SailTypes import *
import manualCode

import sys

"""
Each ast element should support:
 - pp() pretty printing function which returns a string (preferably without a
   newline at the end).
 - getType()
 - getEffects([str]) -> set(Str)

Certain ast elements should support:
 - setCallbacks() - (and associated callback function(s)) for the nodes which have children
 - self.resolveNilCB - for nodes which may need to callback
"""

# TODO: make setCallbacks so it takes an argument and sets the current self.resolveNilCB as this argument, then
# TODO: calls setCallbacks on its children.  I.e. make safer.

def sanatiseSymbol(symbol, lower=True, includeFnNames=False):
	'''
	Args:
		- symbol : str
	Return:
		str
	'''
	# Exceptions to the rule below
	if symbol in ['-', '+', '!=']:
		return symbol
	if symbol.lower() in ['val', 'type']:
		return f'sail{symbol.lower()}'

	# Some startswith rules
	replaceMap = {'!': 'write_',
				  '64': 'n64',
				  '32': 'n32',
				  '1': 'one_',
				  '3': 'three_',
				  '5': 'five_',
				  '7': 'seven_',
				  '9': 'nine_'}
	for sw, r in replaceMap.items():
		if symbol.startswith(sw):
			symbol = r + symbol[len(sw):]

	# To avoid shadowing register/function names
	# TODO: get these automatically
	regNames = ['register', 'rflags', 'rip', 'gprs', 'msrs', 'seg-visibles', 'seg-hidden-attrs', 'seg-hidden-bases', 'seg-hidden-limits', 'zmms', 'ctrs']
	functionNames = ['n64-bit-modep', 'mod']
	if includeFnNames:
		shadowedNames = regNames + functionNames
	else:
		shadowedNames = regNames
	if symbol.lower() in shadowedNames:
		symbol = symbol + '_var'

	# General rules
	# - Replacing -> with _get_ is really just for when functions are manually defined in the ACL2
	#   whose names involve ->, rather than for the automatically defined ones generated by defbitstruct.
	symbol = symbol.replace("->", "_get_")\
					.replace("-", "_")\
					.replace("/", "_")\
					.replace(".", "_")\
					.replace("+", "_plus_")\

	if lower:
		symbol = symbol.lower()\
						.replace("*ip", "iptr")\
						.replace("*sp", "sptr")

	return symbol

def createStructWithDefault(name, fields):
	"""
	Args:
		fields: {str : SailASTelem}
		env: as per normal

	Returns:
		(SailStruct, SailFn)
	"""
	# Map names to types
	names_types = {}
	for n in fields:
		names_types[n] = fields[n].getType()

	# Create the struct
	struct = SailStruct(name, names_types, list(fields.items()))

	# Return
	return struct

def someHelper(item):
	return SailApp(
		fn = SailHandwrittenFn(
			name = 'Some',
			typ = Sail_t_fn([item.getType()], Sail_t_option(item.getType()))),
		actuals = [item])

def noneHelper(typ):
	return SailApp(
		fn = SailHandwrittenFn(
			name = 'None',
			typ = Sail_t_fn([typ], Sail_t_option(typ))),
		actuals = [])

def unionListOfSets(los):
	'''
	Works even when los is empty.  Uses technique here:
	https://stackoverflow.com/questions/31253109/how-can-i-find-the-union-on-a-list-of-sets-in-python#comment104577400_31253153

	Args:
		los: [set()]

	Returns:
		set()
	'''
	return set.union(*[set(), *los])

def checkTypesMatch(items):
	'''
	Returns either (False, None) indicating types don't match or (True, SailType) with the generalised SailType

	Args:
		items: [SailASTelem]

	Returns:
		(bool, SailType)
	'''
	expr_t = items[0].getType().generalise()
	for expr in items[1:]:
		if expr.getType().generalise() != expr_t:
			return False, None

	return True, expr_t

def convertToBool(sailAST):
	'''
	Conditional expression don't always use a bool as their prredicate.  For example, they sometimes use an option
	type, in which case it must we wrapped in an is_some().

	Args:
		sailAST: [SailAST]

	Returns:
		[SailAST]
	'''
	# Get the type of the term
	try:
		ifType = sailAST[0].getType()
	except ValueError:
		# If we can't get the type, assume it's a bool
		ifType = Sail_t_bool()

	# Modify the term term based on its type
	if isinstance(ifType, (Sail_t_bool, Sail_t_unknown)):
		toReturn = sailAST
	elif isinstance(ifType, Sail_t_option):
		toReturn = [SailApp(
			fn=SailHandwrittenFn(
				name='is_some',
				typ=Sail_t_fn([], Sail_t_bool())  # Sort of
			),
			actuals=sailAST
		)]
	else:
		sys.exit(f"Error: don't know how to handle term of type {ifType} in `convertToBool`")

	return toReturn

def isStringList(ys):
	return all(isinstance(y, str) and y.startswith(':') for y in ys)

def convertToStringList(ys, env):
	'''
	Returns either (True, [SailASTelems]) or (False, None)
	'''
	if not isStringList(ys):
		return False, None

	ysSail = []
	for y in ys:
		ySail, env, _ = transform.transformACL2asttoSail(y, env)
		ysSail.append(ySail[0])

	return True, ysSail

def resolveNils(exprs):
	'''
	If any of the exprs is a nil, attempts to resolve it using the other exprs.  If any of the exprs is a tuples,
	attempts to resolve nils within it using the other exprs.

	Args:
		exprs: [SailASTelem]

	Returns:

	'''

	def resolveNilsInner(otherTypes, theNil):
		'''
		otherTypes is a list of types representing the other branches.  theNil is the nil or throw whose type we are
		setting.  There could be more nils/throws in the other branches, so we must first filter them out out
		otherTypes.

		Args:
			otherTypes: [SailType]
			theNil: SailPlaceholderNil \ SaillApp (with a 'throw')

		Returns:
			None
		'''
		# Filter out nils from the other types
		otherTypes = [typ for typ in otherTypes if not (isinstance(typ, Sail_t_PlaceholderNil) or isinstance(typ, Sail_t_error))]

		# Check all the other types are the same
		if any([t != otherTypes[0] for t in otherTypes]):
			print("Warning: types don't match")
			return

		# If we've removed averything in otherTypes, can't do much!
		if not otherTypes:
			return

		# Resolve
		theNil.resolve(otherTypes[0])

	#### Onto the actual body of the function
	# Iterate through the expressions we're given
	for (i, e) in enumerate(exprs):
		# Get a list of all expressions but this one
		otherExprs = exprs[:i] + exprs[i + 1:]

		# If the expression is a nil or a `throw`, resolve directly against the other expressions' types
		if isinstance(e, SailPlaceholderNil) or (isinstance(e, SailApp) and e.getFn().getName().lower() == 'throw'):
			# Get the types of the other terms and filter out nils
			otherTypes = [oe.getType().generalise() for oe in otherExprs]
			resolveNilsInner(otherTypes, e)

		# If the expression is a tuple, go through it looking for nils to resolve and resolve against the types of the
		# expressions at the correct index in their tuple if types
		elif isinstance(e, SailTuple):
			for (j, sub_e) in enumerate(e.getItems()):
				if isinstance(sub_e, SailPlaceholderNil):
					otherTypes = [oe.getType().generalise().getSubTypes()[j] for oe in otherExprs]
					resolveNilsInner(otherTypes, sub_e)

		# Otherwise we don't know what to do so don't do anything
		else:
			pass

class SailASTelem():
	def __init__(self):
		pass

	def getChildrenByPred(self, p):
		if p(self):
			return set([self])
		else:
			return set()

class SailFn(SailASTelem):
	"""Sail function definition"""
	def __init__(self, name=None, formals=None, body=None):
		'''
		It is not neccessary to set the function body at initialistion.  This
		is because we want to create this object before the body is translated
		in order to allow recursion to take place.

		Args:
			- name : str
			- formals : [SailBoundVar]
			- body : [SailAstElem]
		'''
		self.setName(name)
		self.formals = formals
		self.setBody(body)

		self.forceRHSType = None

	# def __init__(self, name=None, formals=None, body=None, typ=None):
	# 	'''
	# 	It is not neccessary to set the function body at initialistion.  This
	# 	is because we want to create this object before the body is translated
	# 	in order to allow recursion to take place.
	#
	# 	Args:
	# 		- name : str
	# 		- formals : [str]
	# 		- body : [SailAstElem]
	# 		- typ : Sail_t_fn
	# 	'''
	# 	self.setName(name)
	# 	self.formals = formals
	# 	self.setBody(body)
	# 	self.typ = typ

	### Custom methods ###
	def setName(self, name):
		if name == None:
			self.name = None
		else:
			self.name = sanatiseSymbol(name)

	def getName(self):
		return self.name

	def getFormals(self):
		return self.formals

	def setFormals(self, formals):
		self.formals = formals

	# def setFormals(self, formals):
	# 	self.formals = formals

	def getNumFormals(self):
		return len(self.formals)

	def setBody(self, body):
		if body != None and len(body) != 1:
			sys.exit(f"Length of function body not 1: {body}")
		self.body = body

	def getBody(self):
		return self.body

	def setForceRHSType(self, typ):
		self.forceRHSType = typ

	# def setType(self, typ):
	# 	self.typ = typ

	def setKeyDefaults(self, keyDefaults):
		self.keyDefaults = keyDefaults

	### Required methods ###
	def getType(self):
		if self.forceRHSType == None:
			return Sail_t_fn(
				lhs=[f.getType() for f in self.formals],
				rhs=self.body[0].getType()
			)
		else:
			return Sail_t_fn(
				lhs=[f.getType() for f in self.formals],
				rhs=self.forceRHSType
			)

	def getEffects(self, ctx):
		ctx.append(self.name)
		toReturn = self.body[0].getEffects(ctx)
		ctx.pop()

		return toReturn

	def getChildrenByPred(self, p):
		formalsSet = unionListOfSets(f.getChildrenByPred(p) for f in self.formals)
		bodySet = self.body[0].getChildrenByPred(p)

		selfSet = super().getChildrenByPred(p)

		return set.union(formalsSet, bodySet, selfSet)

	def pp(self):
		sanatisedName = sanatiseSymbol(self.name)

		# Only construct an effects string if there are any effects
		if len(self.getEffects([])) != 0:
			effectsInner = ", ".join(self.getEffects([]))
			effectsString = f" effect {{{effectsInner}}}"
		else:
			effectsString = ""

		# Combine
		typeSig = f"val {sanatisedName} : {self.getType().generalise().pp()}{effectsString}"
		header = f"function {sanatisedName} ({', '.join([sanatiseSymbol(item.getName(), includeFnNames=True) for item in self.formals])}) ="
		body = "\n".join([elem.pp() for elem in self.body])

		return "\n".join([typeSig, header, body]) + "\n"

	### Nil Resolution ###
	def resolveNil(self, caller):
		# Fail
		sys.exit("Nil resolution reached a function definition")

	def setCallbacks(self):
		self.body[0].resolveNilCB = self.resolveNil
		self.body[0].setCallbacks()

class SailHandwrittenFn(SailASTelem):
	"""
	Some functions we will write by hand because there is little
	point in trying to translate them.  Basic and utility functions
	fall in this category, e.g. common arithmetic ops like addition.

	These handwritten funtions are resident in another file, but objects
	of this type represent which functions are available to us, and their
	type.
	"""
	def __init__(self, name, typ = None):
		'''
		Args:
			- name : str
			- typ : Sail_t_fn
		'''
		self.name = sanatiseSymbol(name, lower=False)
		self.typ  = typ

	### Custom methods ###
	def getName(self):
		return self.name

	def getNumFormals(self):
		return self.typ.getNumFormals()

	def setType(self, t):
		self.typ = t

	### Required methods ###
	def getType(self):
		return self.typ.generalise()

	def getEffects(self, ctx):
		return self.typ.getEffects()

	def pp(self):
		sys.exit("Error: handwritten sail functions are already defined and so their pp() function should not be called")

	### Nil resolution ###
	# Not required

class SailLet(SailASTelem):
	"""Let expression in Sail"""
	def __init__(self, varName, expr, body):
		'''
		For: `let varName = expr in body`
		Or:  `let (x, y) = expr in body`

		Args:
			- varName : SailBoundVar | SailTuple
			- expr : [SailAstElem]
			- body : [SailAstElem]
		'''
		if len(expr) != 1: sys.exit(f"Error: expr length not 1 in `let` getEffects - {expr}")
		if len(body) != 1: sys.exit(f"Error: body length not 1 in `let` getEffects - {body}")

		self.varName = varName
		self.expr = expr
		self.body = body

		# TODO: remove this hack, probably by implementing proper Nil inference
		if isinstance(varName, SailBoundVar) and varName.getName().lower() in ['check-alignment?', 'inst-ac?'] and isinstance(self.expr[0], SailPlaceholderNil):
			self.varName.setType(Sail_t_bool())
			self.expr = [SailBoolLit(False)]

		self.resolveNilCB = None

	### Custom Methods ###
	def getVarName(self):
		return self.varName

	def getExpr(self):
		return self.expr

	def resolveTypes(self, file, justPrint=False):
		file.write(f"Let Resolve Types - {self.varName.pp()}\n")
		file.write(f"Binding: {self.varName.getType().pp()}\n")
		file.write(f"Expression: {self.expr[0].getType().pp()}\n\n")

		sys.exit("Implement resolving of types of SailLet")

	### Required methods ###
	def getType(self):
		# Filter and check length
		bodyFiltered = manualCode.filterAST(self.body, comments=True)
		if len(bodyFiltered) != 1: sys.exit(f"Error: incorrect body length in `let` - {bodyFiltered}")

		return bodyFiltered[0].getType()

	def getEffects(self, ctx):
		exprEffects = self.expr[0].getEffects(ctx).copy()
		bodyEffects = self.body[0].getEffects(ctx).copy()

		totalEffects = exprEffects.union(bodyEffects)

		return totalEffects

	def getChildrenByPred(self, p):
		if p(self.varName):
			varSet = set(self.varName)
		else:
			varSet = set()

		exprSet = self.expr[0].getChildrenByPred(p)
		bodySet = self.body[0].getChildrenByPred(p)

		selfSet = super().getChildrenByPred(p)

		return set.union(varSet, exprSet, bodySet, selfSet)

	def pp(self):
		# Return
		return f"let {self.varName.pp()} = {self.expr[0].pp()} in\n({self.body[0].pp()}) : {self.body[0].getType().generalise().pp()}"

	### Nil resolution ###
	def resolveNilExpr(self, caller):
		# Fail
		sys.exit("Nil resolution reached a let binding")

	def resolveNilBody(self, caller):
		# Defer to parent
		return self.resolveNilCB(self)

	def setCallbacks(self):
		self.expr[0].resolveNilCB = self.resolveNilExpr
		self.expr[1].resolveNilCB = self.resolveNilBody

		self.expr[0].setCallbacks()
		self.expr[1].setCallbacks()

class SailPlaceholderNil(SailASTelem):
	"""Represents a `nil` in the ACL2 code which hasn't yet been resolved in the Sail code"""
	# Class variables
	DEFAULT = 1
	BOOL = 2
	nilTypes = (DEFAULT, BOOL)

	def __init__(self, nilType = 1):
		if nilType not in SailPlaceholderNil.nilTypes: sys.exit("Error: nilType not valid")

		self.resolveNilCB = None
		self.nilType = nilType

	def resolve(self, resolvedType):
		if isinstance(resolvedType, Sail_t_option) and isinstance(resolvedType.getTyp(), Sail_t_string):
			self.nilType = SailPlaceholderNil.DEFAULT
		elif isinstance(resolvedType, Sail_t_bool):
			self.nilType = SailPlaceholderNil.BOOL
		else:
			print(f"Warning: tried setting SailPlaceholderNil to invalid type - {resolvedType}, {resolvedType.pp()} - will keep as default")

	### Required methods ###
	def getType(self):
		if self.nilType == SailPlaceholderNil.DEFAULT:
			return Sail_t_option(Sail_t_string())
		elif self.nilType == SailPlaceholderNil.BOOL:
			return Sail_t_bool()
		else:
			return Sail_t_PlaceholderNil()

	def getEffects(self, ctx):
		return set([])

	def pp(self):
		if self.nilType == SailPlaceholderNil.DEFAULT:
			# TODO: use nonHelper() or similar instead of a raw string
			return 'None() : option(string)'
		elif self.nilType == SailPlaceholderNil.BOOL:
			# TODO: use SailBoolLit instead of a raw string
			return 'false'
		else:
			sys.exit("Error: Tried to pp unresolved nil")

	### Nil resolution ###
	# def resolve(self):
	# 	resolvedType = self.resolveNilCB(self)
	#
	# 	if isinstance(resolvedType, Sail_t_tuple):
	# 		self.nilType = SailPlaceholderNil.DEFAULT
	# 	elif isinstance(resolvedType, Sail_t_bool):
	# 		self.nilType = SailPlaceholderNil.BOOL
	# 	else:
	# 		sys.exit(f"Error: a nil object reveived an unknown type in response to its resolution request - {resolvedType}")

class SailBoundVar(SailASTelem):
	"""Represents a bound variable (e.g. from formal parameters of a function
	of from b*/let bindings"""
	def __init__(self, binding, typ=None):
		'''
		Args:
			- binding : str
			- typ : SailType
		'''
		self.binding = binding
		self.setType(typ)

	def getName(self):
		return self.binding

	### Custom methods ###
	def setType(self, typ):
		'''
		Args:
			- typ : SailType
		'''
		self.typ = typ

		if self.binding.lower() == 'x86':
			if typ == None or isinstance(typ, Sail_t_unknown):
				self.typ = Sail_t_int()
			# else the type is being set explicitely, which we allow.

	### Required methods ###
	def getType(self):
		if self.typ != None:
			return self.typ
		else:
			raise ValueError(f"Error: type of Sail `boundVar` is None - {self.binding}")

	def getEffects(self, ctx):
		return set([])

	def pp(self):
		# BIG HACK
		# TODO: remove printing the type for as many cases as possible
		if sanatiseSymbol(self.binding) in ['les_lds_distinguishing_byte', 'max_offset']:
			return f"{sanatiseSymbol(self.binding, includeFnNames=True)} : {self.getType().pp()}"
		else:
			return sanatiseSymbol(self.binding, includeFnNames=True)

	### Nil resolution ###
	# Not required

class SailApp(SailASTelem):
	"""Represents function application in sail"""
	def __init__(self, fn, actuals, infix = False):
		'''
		Args:
			- fn : SailFn | SailHandwrittenFn
			- actuals : [SailAstElems]
			- infix : Bool
		'''
		self.fn = fn
		self.actuals = actuals
		self.infix = infix

	### Custom methods ###
	def getFn(self):
		return self.fn

	def getActuals(self):
		return self.actuals

	def resolveTypes(self, file, justPrint = False):
		formalTypes = self.fn.getType().getLHS()
		actualTypes = [a.getType() for a in self.actuals]

		file.write(f"App Resolve Types - {self.fn.getName()}\n")
		file.write(f"Formals: {[f.pp() for f in formalTypes]}\n")
		file.write(f"Actuals: {[at.pp() for at in actualTypes]}\n\n")

		if not justPrint:
			# Go through terms resolving types if necessary
			for i in range(len(self.actuals)):
				fType = formalTypes[i]
				aType = actualTypes[i]
				# If neither are unknown, we need not do anything so continue:
				if not (isinstance(fType, Sail_t_unknown) or isinstance(aType, Sail_t_unknown)):
					continue
				# If both are unknown, we can't do anything so continue:
				if isinstance(fType, Sail_t_unknown) and isinstance(aType, Sail_t_unknown):
					continue
				# Otherwise, resolve the unknown var.  Note:
				# - Only a SailBoundVar can have raw type of Sail_t_unknown, so we shoul be safe using its setType() method
				# - self.fn must be a SailFn (not a SailHandwrittenFn) by this point.
				unknownTerm = self.actuals[i] if isinstance(aType, Sail_t_unknown) else self.fn.getFormals()[i]
				knownType = formalTypes[i] if isinstance(aType, Sail_t_unknown) else actualTypes[i]
				unknownTerm.setType(knownType)

	def resolve(self, resolvedType):
		'''
		Used for resolving `throw`.

		Args:
			resolvedType: SailType

		Returns:
			None
		'''
		if self.fn.getName().lower() != 'throw':
			print(f"Warning, try to resovle type of application to function {self.fn.getName()}")
		else:
			self.fn.setType(Sail_t_fn([], resolvedType, {'escape'}))

	### Required methods ###
	def getType(self):
		if self.fn.getType() == None:
			sys.exit(f"Error: function {self.fn.getName()} has not RHS type - you may need to specify it yourself")
		return self.fn.getType().getRHS()

	def getEffects(self, ctx):
		# Check if function has any asssociated effects
		if self.fn.getName() in ctx:
			fnEffects = set([])
		else:
			fnEffects = self.fn.getEffects(ctx).copy()

		# Check if the evaluation of actuals causes any effects
		actualsEffects = [a.getEffects(ctx) for a in self.actuals]

		return fnEffects.union(*actualsEffects)

	def getChildrenByPred(self, p):
		# We ignore functions in the expectation they add themselves, but do want to take into account
		# handwritten functions here
		if isinstance(self.fn, SailHandwrittenFn):
			fnSet = self.fn.getChildrenByPred(p)
		else:
			fnSet = set()

		actualsSet = unionListOfSets([a.getChildrenByPred(p) for a in self.actuals])

		selfSet = super().getChildrenByPred(p)

		return set.union(fnSet, actualsSet, selfSet)

	def pp(self):
		fnName = self.fn.getName()

		# If we're not infix, print normally, otherwise check we're well formed and print infix
		if not self.infix:
			ppString = f"{fnName}({', '.join([elem.pp() for elem in self.actuals])})"
		elif isinstance(self.fn, SailFn):
			sys.exit("Error: can't pretty print SailFn as infix - must be SailHandwrittenFn")
		elif len(self.actuals) != 2:
			sys.exit("Error: can't pretty print infix function which doesn't have exactly 2 actuals")
		else:
			ppString = f"({self.actuals[0].pp()}) {fnName} ({self.actuals[1].pp()})"

		# Hack - reduce printing of type as much as possible
		if self.fn.getName() == '==' and \
				isinstance(self.actuals[0], SailApp) and \
				sanatiseSymbol(self.actuals[0].getFn().getName()) in ['vex3_byte1_get_m_mmmm']:

			return f"({ppString}) : {self.getType().generalise().pp()}"
		else:
			return ppString

	### Nil Resolution ###
	def resolveNil(self, caller):
		sys.exit("Nil resolution reached a usage in app")

	def setCallbacks(self):
		for a in self.actuals:
			a.resolveNilCB = self.resolveNil
			a.setCallbacks()

class SailNumLit(SailASTelem):
	"""A number literal"""
	def __init__(self, num):
		'''
		Args:
			- num : int | float
		'''
		if type(num) not in [int, float]:
			print(f"Error: {num}")
			raise
		self.num = num

	### Custom methods ###
	def getNum(self):
		return self.num

	### Required methods ###
	def getType(self):
		'''
		TODO: return something more specific and implement some more sophisticated checking
		'''
		if self.num > 0:
			return Sail_t_int()
		else:
			return Sail_t_int()

	def getEffects(self, ctx):
		return set([])

	def pp(self):
		return str(self.num)

	### Nil resolution ###
	# Not required

class SailBoolLit(SailASTelem):
	"""A boolean literal"""
	def __init__(self, b):
		'''
		Args:
			bool: bool
		'''
		self.b = b

	### Custom methods ###
	def getBool(self):
		return self.b

	### Required methods ###
	def getType(self):
		return Sail_t_bool()

	def getEffects(self, ctx):
		return set([])

	def pp(self):
		return 'true' if self.b else 'false'

	### Nil resolution ###
	# Not required

class SailStringLit(SailASTelem):
	"""A string literal"""
	def __init__(self, s):
		'''
		Args:
			s: str
		'''
		self.s = s

	def getString(self):
		return self.s

	### Required methods ###
	def getType(self):
		return Sail_t_string()

	def getEffects(self, ctx):
		return set([])

	def pp(self):
		return f'"{self.s}"'

	### Nil resolution ###
	# Not required

class SailUnderScoreLit(SailASTelem):
	"""An underscore"""
	def __init__(self):
		pass

	### Required methods ###
	def getType(self):
		sys.exit("Can't get type of Sail underscore")

	def getEffects(self, ctx):
		return set([])

	def pp(self):
		return "_"

	### Nil resolution ###
	# Not required

class SailIf(SailASTelem):
	"""An `if` statement"""
	def __init__(self, ifTerm, thenTerm, elseTerm):
		'''
		Args:
			- ifTerm: [SailAstElems]
			- thenTerm: [SailAstElems]
			- elseTerm: [SailAstElems]
		'''
		# Check length
		if len(ifTerm)   != 1: sys.exit(f"Error: ifTerm length should be 1: {ifTerm}")
		if len(thenTerm) != 1: sys.exit(f"Error: thenTerm length should be 1: {thenTerm}")
		if len(elseTerm) != 1: sys.exit(f"Error: elseTerm length should be 1: {elseTerm}")

		# Convert the if term to the correct type
		self.ifTerm = convertToBool(ifTerm)

		# Hack: If have string as `then` and nil as `else` then make the string a Some(string) - for `create-dispatch-for-opcodes`
		if isinstance(thenTerm[0], SailStringLit) and isinstance(elseTerm[0], SailPlaceholderNil):
			thenTerm = [someHelper(thenTerm[0])]

		# Hack: If have 'error' as one of the branches and it's from a 'throw' then set its type to the other branch
		# TODO: remove if the below works
		# for (b1, b2) in [(thenTerm, elseTerm), (elseTerm, thenTerm)]:
		# 	if isinstance(b2[0], SailApp) and b2[0].getFn().getName().lower() == 'throw' \
		# 		and not isinstance(b1[0].getType(), Sail_t_error):
		# 		b2[0].getFn().setType(Sail_t_fn([], b1[0].getType()))

		#### Generalising the above hack - nil resolution #####
		resolveNils([thenTerm[0], elseTerm[0]])

		# Set the then and else terms
		self.thenTerm = thenTerm
		self.elseTerm = elseTerm

		self.resolveNilCB = None

	### Required methods ###
	def getType(self):
		# Extract types and check they're the same
		thenType = self.thenTerm[0].getType()
		elseType = self.elseTerm[0].getType()
		if thenType != elseType:
			if isNumeric(thenType) and isNumeric(elseType):
				return Sail_t_int()
			elif isinstance(thenType, Sail_t_tuple) and isinstance(elseType, Sail_t_tuple):
				if thenType != elseType:
					print("Error: then tuple not compatible with else tuple")
					print(f"\tThen tuple/type: {self.thenTerm[0].pp()} : {thenType.pp()}")
					print(f"\tElse tuple/type: {self.elseTerm[0].pp()} : {elseType.pp()}")
					sys.exit()
				else:
					return thenType
			else:
				print(f"Error: then type not compatible with else type.  then type: {thenType.pp()}; else type: {elseType.pp()}")
				print(f"if term: {self.ifTerm[0].pp()}; then term: {self.thenTerm[0].pp()}, else term: {self.elseTerm[0].pp()}")
				sys.exit()
		else:
			if isinstance(thenType, Sail_t_error) and isinstance(elseType, Sail_t_error):
				sys.exit("Error: Both branches have `any` type")
			elif isinstance(thenType, Sail_t_error):
				return elseType
			elif isinstance(elseType, Sail_t_error):
				return thenType
			else:
				return thenType

	def getEffects(self, ctx):
		# Extract effects from each term and combine
		ifEffects = self.ifTerm[0].getEffects(ctx).copy()
		thenEffects = self.thenTerm[0].getEffects(ctx).copy()
		elseEffects = self.elseTerm[0].getEffects(ctx).copy()

		return ifEffects.union(thenEffects, elseEffects)

	def getChildrenByPred(self, p):
		ifSet = self.ifTerm[0].getChildrenByPred(p)
		thenSet = self.thenTerm[0].getChildrenByPred(p)
		elseSet = self.elseTerm[0].getChildrenByPred(p)

		selfSet = super().getChildrenByPred(p)

		return set.union(ifSet, thenSet, elseSet, selfSet)

	def pp(self):
		# Uncomment the following block to remove the check for proc_mode and only translate the 64-bit branch.
		# TODO: would probably be better doing this in either exclusions or a post-process pass of the AST
		# if isinstance(self.ifTerm[0], SailApp) and self.ifTerm[0].getFn().getName() == '==':
		# 	actuals = self.ifTerm[0].getActuals()
		# 	if isinstance(actuals[0], SailBoundVar) and actuals[0].getName().lower() == 'proc-mode' and \
		# 		isinstance(actuals[1], SailNumLit) and actuals[1].getNum() == 0:
		#
		# 		return self.thenTerm[0].pp()

		# Normal
		ifPP = self.ifTerm[0].pp()
		thenPP = self.thenTerm[0].pp()
		elsePP = self.elseTerm[0].pp()
		return f"if {ifPP}\nthen {thenPP}\nelse {elsePP}"

	### Nil resolution ###
	def resolveNilIf(self, caller):
		sys.exit("Nil resolution reach `if` part of an `if` statement")

	def mkResolveNil(self, isThen):
		def resolveNil(caller):
			# Get the correct term
			if isThen:
				otherTerm = self.elseTerm
			else:
				otherTerm = self.thenTerm

			# Get its type
			otherType = otherTerm[0].getType()

			# Return it or ask parent
			if isinstance(elseType, Sail_t_PlaceholderNil):
				# Hope we get resolution further up
				return self.resolveNilCB(self)
			else:
				return otherType

		return resolveNil

	def setCallbacks(self):
		self.ifTerm[0].resolveNilCB = resolveNilIf
		self.thenTerm[0].resolveNilCB = self.mkResolveNil(True)
		self.elseTerm[0].resolveNilCB = self.mkResolveNil(False)

		self.ifTerm[0].setCallbacks()
		self.thenTerm[0].setCallbacks()
		self.elseTerm[0].setCallbacks()

# class SailCast():
# 	"""A Sail type annotation"""
# 	def __init__(self, expr, typ, ppCast = False):
# 		'''
# 		Args:
# 			- expr : [SailASTelem]
# 			- typ : SailType
# 			- ppCast : bool - whether to print the cast when 'pp'ing
# 		'''
# 		# Check length
# 		if len(self.expr) != 1: sys.exit(f"Expr length not 1 in `SailCast` - {self.expr}")
#
# 		self.expr = expr
# 		self.typ = typ
# 		self.ppCast = ppCast
#
# 	def setppCast(self, ppCast):
# 		self.ppCast = ppCast
#
# 	def getExpr(self):
# 		return self.expr
#
# 	def getType(self):
# 		return self.typ
#
# 	def getEffects(self, ctx):
# 		return self.expr[0].getEffects(ctx)
#
# 	def pp(self):
# 		if self.ppCast:
# 			return f"{self.expr[0].pp()} : {self.typ.pp()}"
# 		else:
# 			return self.expr[0].pp()

class SailInclude(SailASTelem):
	"""Represents an `$include` expression"""
	def __init__(self, sailAST, path, file, includeHeaders, env):
		'''
		Args:
			- sailAST : [SailASTelem]
			- path : str
			- file : str - should not include an extenstion
			- includeheaders : bool
			- env : env
		'''
		self.sailAST = sailAST
		self.path = path
		self.file = sanatiseSymbol(file)
		self.includeHeaders = includeHeaders
		self.savedOut = False
		self.env = env

	### Required methods ###
	def getType(self):
		sys.exit(f"Error: should not try to get type of `SailInclude`")

	def getChildrenByPred(self, p):
		# We probably still want to calculate sailASTset even if self.saveOut is true as we may be analysing
		# a file which hasn't had this included already.
		sailASTset = unionListOfSets(i.getChildrenByPred(p) for i in self.sailAST if not isinstance(i, ACL2Comment))

		selfSet = super().getChildrenByPred(p)

		return set.union(sailASTset, selfSet)

	def pp(self):
		if not self.savedOut:
			# Save out the file
			self.savedOut = True
			transform.saveSail(self.sailAST, self.path, self.file, self.env, self.includeHeaders)

			return f'$include "{self.file}.sail"'

		else:
			return ""

	### Nil resolution ###
	# Not required

class SailTuple(SailASTelem):
	"""Represents a SailTuple"""
	def __init__(self, subItems):
		'''
		Args:
			- subItems : [SailASTelem]
		'''
		self.subItems = subItems

		self.resolveNilCB = None

	### Custom methods ###
	def getItems(self):
		return self.subItems

	### Required methods ###
	def getType(self):
		# Cast items which have a numeric type to int)
		return Sail_t_tuple([item.getType() if not isNumeric(item.getType()) else Sail_t_int() for item in self.subItems])

	def getEffects(self, ctx):
		effects = [e.getEffects(ctx) for e in self.subItems]
		if len(effects) == 0:
			return set([])
		else:
			return set.union(*effects)

	def getChildrenByPred(self, p):
		itemsSet = unionListOfSets(i.getChildrenByPred(p) for i in self.subItems)

		selfSet = super().getChildrenByPred(p)

		return set.union(itemsSet, selfSet)

	def pp(self):
		itemStrings = []
		for i in self.subItems:
			if isinstance(i, SailNumLit):
				itemStrings.append(f"{i.pp()} : {i.getType().pp()}")
			else:
				itemStrings.append(i.pp())
		return f"({', '.join([i for i in itemStrings])})"
		# return f"({', '.join([item.pp() for item in self.subItems])})"

	### Nil resolution ###
	def resolveNil(self, caller):
		# Get the parent type and perform some checks
		parentType = self.resolveNilCB(self)
		if not isinstance(parentType, Sail_t_tuple): sys.exit("Error: parent type not a tuple when tuple requested nil resolution")
		if len(parentType).subItems != len(self.subItems): sys.exit("Error: incompatible type of this tuple vs the parent type")

		# Get index of the caller in our list
		idx = self.subItems.index(caller)

		# Get that index of the parent type
		return parentType.subTypes[idx]

	def setCallbacks(self):
		for item in self.subItems:
			item.resolveNilCB = self.resolveNil
			item.setCallbacks()

class SailMatch(SailASTelem):
	"""Represents a Sail match expression"""
	def __init__(self, var, matches, forceType=None):
		'''
		Args:
			- var : SailBoundVar
			- matches : [(pattern : SailNumLit?|SailUnderscoreLit, expr : SailASTelem)]
			- forceType : None | SailType
		'''
		self.var = var
		self.matches = matches
		self.setForceType(forceType)

		# Hack: Convert the patterns to bool as required
		if isinstance(self.var.getType(), Sail_t_option):
			self.matches = [(someHelper(p), e) if not isinstance(p, SailUnderScoreLit) else (p,e,) for (p, e) in self.matches]

		# Resolve nils for the expressions
		exprs = [e for (_, e) in self.matches]
		resolveNils(exprs)

		self.resolveNilCB = None

	### Custom methods ###
	def getMatches(self):
		return self.matches

	def setForceType(self, ft):
		self.forceType = ft

	### Required methods ###
	def getType(self):
		if self.forceType is None:
			# Get the type of each expression and hope they're the same
			typesWork, expr_t = checkTypesMatch([expr for (_, expr) in self.matches])
			if not typesWork:
				print(f"Error: types of expression in match statement not the same")
				print(self.var)
				for (p, e) in self.matches:
					print(f"\t{p.pp()}, {e.getType().pp()}")
				for (p, e) in self.matches:
					print(f"\t{p.pp()}, {e.pp()}")
				sys.exit()

			return expr_t
		else:
			return self.forceType

	def getEffects(self, ctx):
		effects = [e.getEffects(ctx) for (_, e) in self.matches]
		if len(effects) == 0:
			return set([])
		else:
			return set.union(*effects)

	def getChildrenByPred(self, p):
		varSet = self.var.getChildrenByPred(p)
		matchesSet = unionListOfSets(set.union(pat.getChildrenByPred(p), e.getChildrenByPred(p)) for (pat,e) in self.matches)

		selfSet = super().getChildrenByPred(p)

		return set.union(varSet, matchesSet, selfSet)

	def pp(self):
		# Partial constant folding.  If the variable is actually a string, then we can just use the appropriate
		# expression directly.  This is common when flgi, !flgi and !flgi-undefined have been macro expanded
		if isinstance(self.var, SailStringLit):
			matches = [e for (p, e) in self.matches if isinstance(p, SailStringLit) and p.getString() == self.var.getString()]
			if len(matches) != 1: sys.exit("Incorrect number of possible expressions when constant folding a match")
			return matches[0].pp()

		# Uncomment the following block to remove the check for proc_mode and only translate the 64-bit branch.
		# TODO: would probably be better doing this in either exclusions or a post-process pass of the AST
		# if isinstance(self.var, SailBoundVar) and self.var.getName().lower() == 'proc-mode':
		# 	branch_64_bit = [e for (p,e) in self.matches if isinstance(p, SailNumLit) and p.num == 0]
		# 	if len(branch_64_bit) != 1: sys.exit(f"Wrong number of 64 bit branches: {len(branch_64_bit)}")
		# 	return branch_64_bit[0].pp()
		
		# If constant folding is not applicable, continue as normal
		headerLine = f"match {self.var.pp()} {{"
		matchLines = []
		for (pat, expr) in self.matches:
			matchLines.append(f"{pat.pp()} => {expr.pp()}")
		matchLines = ",\n".join(matchLines)
		together = f"{headerLine}\n{matchLines}\n}}"

		# Add a type annotation
		withAnnotation = f"({together}) : {self.getType().pp()}"

		return withAnnotation

	### Nil resolution ###
	def setCallBacks(self):
		sys.exit("Finish implementing nil resolution functions for SailMatch!")

class SailStruct(SailASTelem):
	"""Represents the definition of Sail struct"""
	def __init__(self, name, fields, defaults=None):
		"""

		Args:
			name: str
			fields: {(name:str) : SailType}
			defaults: [(name:str, SailASTelem)] - compatible with SailStructLit below

		TODO: replace `name` and `fields` with a single list of boundvars
		"""
		self.name = sanatiseSymbol(name)
		self.fields = fields
		self.defaults = defaults

	### Custom methods ###
	def getName(self):
		return self.name

	def getFields(self):
		return self.fields

	def getTypeOfName(self, name):
		return self.fields[name]

	def getDefaults(self):
		return self.defaults

	### Required methods ###
	def getType(self):
		print("Should not try to get type of SailStruct")
		raise

	def getEffects(self, ctx):
		sys.exit("Should not try to get effect of SailStruct")

	def getChildrenByPred(self, p):
		exprsSet = unionListOfSets(e.getChildrenByPred(p) for (_, e) in self.defaults)

		selfSet = super().getChildrenByPred(p)

		return set.union(exprsSet, selfSet)

	def pp(self):
		names_types = []
		for (n, t) in self.fields.items():
			names_types.append(f"{sanatiseSymbol(n)} : {t.pp()}")
		names_types_str = ",\n\t".join(names_types)
		structDefInner = f"{{\n\t{names_types_str}\n}}"
		structDef = f"struct {self.name} = {structDefInner}"

		return structDef

	### Nil resolution ###
	def setCallBacks(self):
		sys.exit("Finish implementing nil resolution functions for SailStruct!")

class SailStructLit(SailASTelem):
	"""Represents a literal struct"""
	def __init__(self, struct, exprs):
		"""
		Args:
			struct: SailStruct
			exprs: [(name:str, SailASTelem)]
		"""
		# Check the types of the expressions match the expected types
		for (n, e) in exprs:
			if e.getType() != struct.getTypeOfName(n):
				print(f"Field name: {n}\nGiven expression: {e.pp()}")
				print(f"Given expression type: {e.getType().pp()}\nExpected expression type: {struct.getTypeOfName(n).pp()}")
				sys.exit("Error: subfield type in a struct literal does not match definition type")

		# Set object fields
		self.struct = struct
		self.exprs = exprs

	### Required methods ###
	def getType(self):
		return Sail_t_struct(self.struct)

	def getEffects(self, ctx):
		effects = [e.getEffects(ctx) for (_, e) in self.exprs]
		if len(effects) == 0:
			return set([])
		else:
			return set.union(*effects)

	def getChildrenByPred(self, p):
		# Ignore struct in the expectation that it has been included when the struct was defined
		# Do include the actuals though.  Sure, they may have been been included as the defaults, but they also
		# May not have been.
		exprSet = unionListOfSets(e.getChildrenByPred(p) for (_, e) in self.exprs)

		selfSet = super().getChildrenByPred(p)

		return set.union(exprSet, selfSet)

	def pp(self):
		names_exprs = []
		for (n, e) in self.exprs:
			names_exprs.append(f"{sanatiseSymbol(n)} = {e.pp()}")

		names_exprs = ", ".join(names_exprs)
		structLitInner = f"{names_exprs}"
		structLit = f"struct {{{structLitInner}}}"

		return structLit

		### Nil resolution ###
		def setCallBacks(self):
			sys.exit("Finish implementing nil resolution functions for SailStructLit!")

class SailStructProject(SailASTelem):
	"""Extract a field from a struct"""
	def __init__(self, sailASTelem, fieldName : str):
		'''
		Args:
			sailASTelem: sailASTelem - must have type Sail_t_struct
			fieldName: str
		'''
		if type(sailASTelem.getType()) != Sail_t_struct:
			sys.exit("Error: type of Sail AST element to project from is not a struct")

		self.sailASTelem = sailASTelem
		self.fieldName = fieldName

		self.struct = self.sailASTelem.getType().getStruct()

	### Required methods ###
	def getType(self):
		return self.struct.getTypeOfName(self.fieldName)

	def getEffects(self, ctx):
		return set([])

	def getChildrenByPred(self, p):
		elemsSet = self.sailASTelem.getChildrenByPred(p)

		selfSet = super().getChildrenByPred(p)

		return set.union(elemsSet, selfSet)

	def pp(self):
		return f"({self.sailASTelem.pp()}).{sanatiseSymbol(self.fieldName)}"

	### Nil resolution ###
	def setCallBacks(self):
		sys.exit("Finish implementing nil resolution functions for SailStructProject!")


class SailVectorLit(SailASTelem):
	"""A Sail vector literal"""
	def __init__(self, items):
		'''
		Args:
			items: [SailASTelem]
		'''
		self.items = items

	### Required methods ###
	def getType(self):
		# Check subitems have the same type here
		typesWork, expr_t = checkTypesMatch(self.items)
		if not expr_t:
			print("Error: types of SailVectorLit not compatible")
			print(f"{self.items}")
			sys.exit()

		return Sail_t_vector(len(self.items), expr_t)

	def getEffects(self, ctx):
		effects = [e.getEffects(ctx) for e in self.items]
		if len(effects) == 0:
			return set([])
		else:
			return set.union(*effects)

	def getChildrenByPred(self, p):
		itemsSet = unionListOfSets(i.getChildrenByPred(p) for i in self.items)

		selfSet = super().getChildrenByPred(p)

		return set.union(itemsSet, selfSet)

	def pp(self):
		# We use `reversed` here because our default order is `dec`
		return f"[{', '.join(item.pp() for item in reversed(self.items))}] : {self.getType().pp()}"

	### Nil resolution ###
	def setCallBacks(self):
		sys.exit("Finish implementing nil resolution functions for SailVectorLit!")


class SailVectorProject(SailASTelem):
	"""A Sail vector projection"""

	def __init__(self, vector, index):
		'''
		Args:
			vector: SailASTelem : Sail_t_vector
			index: SailASTelem : Sail_t_int
		'''
		self.vector = vector
		self.index = index

	### Required methods ###
	def getType(self):
		return self.vector.getType().getSubType()

	def getEffects(self, ctx):
		vectorEffects = self.vector.getEffects(ctx)
		indexEffects = self.index.getEffects(ctx)

		return set.union(vectorEffects, indexEffects, {'escape'})

	def getChildrenByPred(self, p):
		vectorSet = self.vector.getChildrenByPred(p)
		indexSet = self.index.getChildrenByPred(p)

		selfSet = super().getChildrenByPred(p)

		return set.union(vectorSet, indexSet, selfSet)

	def pp(self):
		return\
f"""let vectorIndex = {self.index.pp()} in {{
	assert(0 <= vectorIndex & vectorIndex <= {self.vector.getType().getLength() - 1});
	({self.vector.pp()})[vectorIndex]
}}"""
		# return f"({self.vector.pp()})[{self.index.pp()}]"

	### Nil resolution ###
	def setCallBacks(self):
		sys.exit("Finish implementing nil resolution functions for SailVectorProject!")

class SailListLit(SailASTelem):
	"A Sail list literal"
	def __init__(self, members):
		'''
		Args:
			members: [SailASTelem]
		'''
		check, _ = checkTypesMatch(members)
		if not check:
			sys.exit(f"Error: types of list members don't match in init() - {members}")

		self.members = members

	### Required methods ###
	def getType(self):
		check, subtype = checkTypesMatch(self.members)
		if not check:
			sys.exit(f"Error: types of list members don't match in getType() - {members}")

		return Sail_t_list(subtype)

	def getEffects(self, ctx):
		return unionListOfSets([m.getEffects(ctx) for m in self.members])

	def getChildrenByPred(self, p):
		memberSet = unionListOfSets([m.getChildrenByPred(p) for m in self.members])

		selfSet = super().getChildrenByPred(p)

		return set.union(memberSet, selfSet)

	def pp(self):
		return f"[|{', '.join([m.pp() for m in self.members])}|]"

	### Nil resolution ###
	def setCallBacks(self):
		sys.exit("Finish implementing nil resolution functions for SailListLit!")